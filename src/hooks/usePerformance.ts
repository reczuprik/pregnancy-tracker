import { useEffect, useCallback, useRef } from 'react';\n\n/**\n * Performance monitoring hook\n * Provides utilities for measuring and optimizing performance\n */\nexport function usePerformance() {\n  const performanceRef = useRef<Map<string, number>>(new Map());\n\n  const startTiming = useCallback((label: string) => {\n    performanceRef.current.set(label, performance.now());\n  }, []);\n\n  const endTiming = useCallback((label: string) => {\n    const startTime = performanceRef.current.get(label);\n    if (startTime) {\n      const duration = performance.now() - startTime;\n      performanceRef.current.delete(label);\n      \n      // Log slow operations in development\n      if (process.env.NODE_ENV === 'development' && duration > 100) {\n        console.warn(`Slow operation detected: ${label} took ${duration.toFixed(2)}ms`);\n      }\n      \n      return duration;\n    }\n    return 0;\n  }, []);\n\n  const measureAsync = useCallback(async <T>(\n    label: string,\n    operation: () => Promise<T>\n  ): Promise<T> => {\n    startTiming(label);\n    try {\n      const result = await operation();\n      endTiming(label);\n      return result;\n    } catch (error) {\n      endTiming(label);\n      throw error;\n    }\n  }, [startTiming, endTiming]);\n\n  return {\n    startTiming,\n    endTiming,\n    measureAsync\n  };\n}\n\n/**\n * Debounce hook for performance optimization\n */\nexport function useDebounce<T extends (...args: any[]) => any>(\n  callback: T,\n  delay: number\n): T {\n  const timeoutRef = useRef<NodeJS.Timeout>();\n  const callbackRef = useRef(callback);\n  callbackRef.current = callback;\n\n  return useCallback((\n    (...args: Parameters<T>) => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        callbackRef.current(...args);\n      }, delay);\n    }\n  ) as T, [delay]);\n}\n\n/**\n * Throttle hook for performance optimization\n */\nexport function useThrottle<T extends (...args: any[]) => any>(\n  callback: T,\n  limit: number\n): T {\n  const inThrottle = useRef(false);\n  const callbackRef = useRef(callback);\n  callbackRef.current = callback;\n\n  return useCallback((\n    (...args: Parameters<T>) => {\n      if (!inThrottle.current) {\n        callbackRef.current(...args);\n        inThrottle.current = true;\n        setTimeout(() => {\n          inThrottle.current = false;\n        }, limit);\n      }\n    }\n  ) as T, [limit]);\n}\n\n/**\n * Memory usage monitoring hook\n */\nexport function useMemoryMonitor() {\n  const getMemoryUsage = useCallback(() => {\n    if ('memory' in performance) {\n      const memInfo = (performance as any).memory;\n      return {\n        used: Math.round(memInfo.usedJSHeapSize / 1048576 * 100) / 100,\n        total: Math.round(memInfo.totalJSHeapSize / 1048576 * 100) / 100,\n        limit: Math.round(memInfo.jsHeapSizeLimit / 1048576 * 100) / 100\n      };\n    }\n    return null;\n  }, []);\n\n  useEffect(() => {\n    if (process.env.NODE_ENV === 'development') {\n      const interval = setInterval(() => {\n        const memUsage = getMemoryUsage();\n        if (memUsage && memUsage.used > 50) {\n          console.warn('High memory usage detected:', memUsage);\n        }\n      }, 10000); // Check every 10 seconds\n\n      return () => clearInterval(interval);\n    }\n  }, [getMemoryUsage]);\n\n  return { getMemoryUsage };\n}\n\n/**\n * Virtual scrolling hook for large lists\n */\nexport function useVirtualScroll({\n  items,\n  itemHeight,\n  containerHeight\n}: {\n  items: any[];\n  itemHeight: number;\n  containerHeight: number;\n}) {\n  const [scrollTop, setScrollTop] = useState(0);\n  \n  const visibleStart = Math.floor(scrollTop / itemHeight);\n  const visibleEnd = Math.min(\n    visibleStart + Math.ceil(containerHeight / itemHeight) + 1,\n    items.length\n  );\n  \n  const visibleItems = items.slice(visibleStart, visibleEnd);\n  const totalHeight = items.length * itemHeight;\n  const offsetY = visibleStart * itemHeight;\n\n  const handleScroll = useCallback((e: React.UIEvent<HTMLElement>) => {\n    setScrollTop(e.currentTarget.scrollTop);\n  }, []);\n\n  return {\n    visibleItems,\n    totalHeight,\n    offsetY,\n    handleScroll\n  };\n}