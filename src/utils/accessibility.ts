/**\n * Accessibility utilities and helpers\n * Provides functions to improve app accessibility\n */\n\n/**\n * Announces content to screen readers\n */\nexport function announceToScreenReader(message: string, priority: 'polite' | 'assertive' = 'polite') {\n  const announcer = document.createElement('div');\n  announcer.setAttribute('aria-live', priority);\n  announcer.setAttribute('aria-atomic', 'true');\n  announcer.setAttribute('class', 'sr-only');\n  announcer.textContent = message;\n  \n  document.body.appendChild(announcer);\n  \n  // Remove after announcement\n  setTimeout(() => {\n    document.body.removeChild(announcer);\n  }, 1000);\n}\n\n/**\n * Manages focus for keyboard navigation\n */\nexport class FocusManager {\n  private static focusableElements = [\n    'button',\n    'input',\n    'select',\n    'textarea',\n    'a[href]',\n    '[tabindex]:not([tabindex=\"-1\"])'\n  ].join(',');\n\n  static getFocusableElements(container: Element): HTMLElement[] {\n    return Array.from(\n      container.querySelectorAll(this.focusableElements)\n    ) as HTMLElement[];\n  }\n\n  static trapFocus(container: Element) {\n    const focusableElements = this.getFocusableElements(container);\n    const firstElement = focusableElements[0];\n    const lastElement = focusableElements[focusableElements.length - 1];\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'Tab') {\n        if (e.shiftKey) {\n          // Shift + Tab\n          if (document.activeElement === firstElement) {\n            e.preventDefault();\n            lastElement?.focus();\n          }\n        } else {\n          // Tab\n          if (document.activeElement === lastElement) {\n            e.preventDefault();\n            firstElement?.focus();\n          }\n        }\n      }\n      \n      if (e.key === 'Escape') {\n        // Allow components to handle escape\n        container.dispatchEvent(new CustomEvent('focustrap:escape'));\n      }\n    };\n\n    container.addEventListener('keydown', handleKeyDown);\n    firstElement?.focus();\n\n    return () => {\n      container.removeEventListener('keydown', handleKeyDown);\n    };\n  }\n\n  static restoreFocus(previousActiveElement: Element | null) {\n    if (previousActiveElement instanceof HTMLElement) {\n      previousActiveElement.focus();\n    }\n  }\n}\n\n/**\n * Validates color contrast ratios\n */\nexport function validateColorContrast(foreground: string, background: string): {\n  ratio: number;\n  passes: { aa: boolean; aaa: boolean };\n} {\n  // This is a simplified implementation\n  // In a real app, you'd use a proper color contrast library\n  const getLuminance = (color: string): number => {\n    // Convert hex to RGB and calculate luminance\n    const hex = color.replace('#', '');\n    const r = parseInt(hex.substr(0, 2), 16) / 255;\n    const g = parseInt(hex.substr(2, 2), 16) / 255;\n    const b = parseInt(hex.substr(4, 2), 16) / 255;\n    \n    const getRGB = (c: number) => c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);\n    \n    return 0.2126 * getRGB(r) + 0.7152 * getRGB(g) + 0.0722 * getRGB(b);\n  };\n\n  const l1 = getLuminance(foreground);\n  const l2 = getLuminance(background);\n  const ratio = (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);\n\n  return {\n    ratio,\n    passes: {\n      aa: ratio >= 4.5,\n      aaa: ratio >= 7\n    }\n  };\n}\n\n/**\n * Keyboard navigation helpers\n */\nexport const KeyboardNavigation = {\n  /**\n   * Handle arrow key navigation in lists/grids\n   */\n  handleArrowKeys: (e: KeyboardEvent, items: HTMLElement[], currentIndex: number) => {\n    let newIndex = currentIndex;\n    \n    switch (e.key) {\n      case 'ArrowDown':\n        newIndex = Math.min(items.length - 1, currentIndex + 1);\n        break;\n      case 'ArrowUp':\n        newIndex = Math.max(0, currentIndex - 1);\n        break;\n      case 'Home':\n        newIndex = 0;\n        break;\n      case 'End':\n        newIndex = items.length - 1;\n        break;\n      default:\n        return currentIndex;\n    }\n    \n    e.preventDefault();\n    items[newIndex]?.focus();\n    return newIndex;\n  },\n\n  /**\n   * Handle enter/space activation\n   */\n  handleActivation: (e: KeyboardEvent, callback: () => void) => {\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault();\n      callback();\n    }\n  }\n};\n\n/**\n * Screen reader utilities\n */\nexport const ScreenReader = {\n  /**\n   * Create descriptive text for screen readers\n   */\n  describeMeasurement: (measurement: {\n    parameter: string;\n    value: number;\n    unit: string;\n    percentile?: number;\n  }) => {\n    let description = `${measurement.parameter}: ${measurement.value} ${measurement.unit}`;\n    \n    if (measurement.percentile) {\n      description += `, which is in the ${measurement.percentile}th percentile`;\n    }\n    \n    return description;\n  },\n\n  /**\n   * Create progress announcements\n   */\n  announceProgress: (current: number, total: number, itemType: string) => {\n    return `${itemType} ${current} of ${total}`;\n  },\n\n  /**\n   * Create status announcements\n   */\n  announceStatus: (status: 'loading' | 'success' | 'error', context?: string) => {\n    const messages = {\n      loading: `Loading${context ? ` ${context}` : ''}...`,\n      success: `Successfully ${context || 'completed'}`,\n      error: `Error ${context ? `with ${context}` : 'occurred'}`\n    };\n    \n    return messages[status];\n  }\n};\n\n/**\n * ARIA attributes helpers\n */\nexport const ARIA = {\n  /**\n   * Generate ARIA attributes for expandable content\n   */\n  expandable: (id: string, expanded: boolean) => ({\n    'aria-expanded': expanded,\n    'aria-controls': id,\n    'aria-describedby': `${id}-desc`\n  }),\n\n  /**\n   * Generate ARIA attributes for form validation\n   */\n  validation: (fieldId: string, hasError: boolean, errorId?: string) => ({\n    'aria-invalid': hasError,\n    'aria-describedby': hasError && errorId ? errorId : undefined\n  }),\n\n  /**\n   * Generate ARIA attributes for live regions\n   */\n  liveRegion: (politeness: 'polite' | 'assertive' = 'polite') => ({\n    'aria-live': politeness,\n    'aria-atomic': true\n  })\n};\n\n/**\n * Accessibility testing helpers for development\n */\nexport const A11yTesting = {\n  /**\n   * Check for missing alt text on images\n   */\n  checkImageAltText: () => {\n    if (process.env.NODE_ENV === 'development') {\n      const images = document.querySelectorAll('img');\n      images.forEach((img, index) => {\n        if (!img.alt && !img.getAttribute('aria-hidden')) {\n          console.warn(`Image ${index} missing alt text:`, img);\n        }\n      });\n    }\n  },\n\n  /**\n   * Check for proper heading hierarchy\n   */\n  checkHeadingHierarchy: () => {\n    if (process.env.NODE_ENV === 'development') {\n      const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');\n      let previousLevel = 0;\n      \n      headings.forEach((heading) => {\n        const currentLevel = parseInt(heading.tagName.charAt(1));\n        if (currentLevel > previousLevel + 1) {\n          console.warn(`Heading hierarchy skip detected: ${heading.tagName}`, heading);\n        }\n        previousLevel = currentLevel;\n      });\n    }\n  },\n\n  /**\n   * Check for keyboard-only navigation issues\n   */\n  simulateKeyboardNavigation: () => {\n    if (process.env.NODE_ENV === 'development') {\n      const focusableElements = FocusManager.getFocusableElements(document.body);\n      console.log(`Found ${focusableElements.length} focusable elements:`, focusableElements);\n    }\n  }\n};